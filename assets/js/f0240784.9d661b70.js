"use strict";(self.webpackChunkdocus=self.webpackChunkdocus||[]).push([[3356],{2140:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"pools/smart-contracts/erc20-collateral-pool-contract/smart-contract-erc20-collateral-pool-example","title":"Example","description":"In-depth Actions","source":"@site/docs/pools/smart-contracts/erc20-collateral-pool-contract/example.md","sourceDirName":"pools/smart-contracts/erc20-collateral-pool-contract","slug":"/pools/smart-contracts/erc20-collateral-pool-contract/smart-contract-erc20-collateral-pool-example","permalink":"/docs/pools/smart-contracts/erc20-collateral-pool-contract/smart-contract-erc20-collateral-pool-example","draft":false,"unlisted":false,"editUrl":"https://github.com/defactor-com/documentation/tree/main/docs/pools/smart-contracts/erc20-collateral-pool-contract/example.md","tags":[{"inline":true,"label":"ERC20","permalink":"/docs/tags/erc-20"},{"inline":true,"label":"Collateral Pool","permalink":"/docs/tags/collateral-pool"},{"inline":true,"label":"Borrow","permalink":"/docs/tags/borrow"},{"inline":true,"label":"Supply","permalink":"/docs/tags/supply"}],"version":"current","sidebarPosition":3,"frontMatter":{"id":"smart-contract-erc20-collateral-pool-example","title":"Example","sidebar_position":3,"tags":["ERC20","Collateral Pool","Borrow","Supply"]},"sidebar":"docSidebar","previous":{"title":"Technical Aspects","permalink":"/docs/pools/smart-contracts/erc20-collateral-pool-contract/smart-contract-erc20-collateral-pool-technical-aspects"},"next":{"title":"Pools Backend Overview","permalink":"/docs/pools/back-end/backend-overview"}}');var l=t(4848),o=t(8453);const a={id:"smart-contract-erc20-collateral-pool-example",title:"Example",sidebar_position:3,tags:["ERC20","Collateral Pool","Borrow","Supply"]},s=void 0,i={},d=[{value:"In-depth Actions",id:"in-depth-actions",level:2},{value:"Pool Lifecycle",id:"pool-lifecycle",level:3},{value:"Event #1: Contract Initialization",id:"event-1-contract-initialization",level:3},{value:"Event #2: Supplying Funds",id:"event-2-supplying-funds",level:3},{value:"Event #3: Borrowing Funds",id:"event-3-borrowing-funds",level:3},{value:"Event #4: Repaying the Loan",id:"event-4-repaying-the-loan",level:3},{value:"Event #5: Claiming Rewards",id:"event-5-claiming-rewards",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"in-depth-actions",children:"In-depth Actions"}),"\n",(0,l.jsx)(n.p,{children:"The happy path for this Smart Contract begins with the initialization of a pool, where suppliers provide funds, allowing borrowers to interact with the contract as needed. A common concern is what happens if a borrower fails to repay the loan. To mitigate this risk, borrowers must provide collateral tokens that secure the amount they are requesting. They are required to repay the loan with interest before it become liquidatable and be liquidated by another user."}),"\n",(0,l.jsxs)(n.p,{children:["Each time USDC is transferred, an internal function is triggered to update the variables that calculate rewards for the suppliers. This function updates the following variables: ",(0,l.jsx)(n.code,{children:"rewardPerToken"}),", ",(0,l.jsx)(n.code,{children:"rewardRate"}),", and ",(0,l.jsx)(n.code,{children:"lastUpdated"}),". Here's how this function looks:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-solidity",children:"pool.rewardPerToken += ((block.timestamp - pool.lastUpdated) * pool.rewardRate);\npool.rewardRate = (pool.lended - pool.claimed) > 0 ?\n    (((pool.borrowed - pool.repaid) * pool.interest * 1e18) /\n    ((pool.lended - pool.claimed) * ONE_YEAR * BPS_DIVIDER)) : 0;\npool.lastUpdated = uint48(block.timestamp);\n"})}),"\n",(0,l.jsxs)(n.p,{children:["For example, when someone first supplies to the pool, the ",(0,l.jsx)(n.code,{children:"rewardPerToken"})," will be ",(0,l.jsx)(n.code,{children:"0"}),", the ",(0,l.jsx)(n.code,{children:"rewardRate"})," will reflect the pool's interest rate, and ",(0,l.jsx)(n.code,{children:"lastUpdated"})," will be set to the timestamp of the block when the first lender contributed. The next time someone lends to the pool, ",(0,l.jsx)(n.code,{children:"rewardPerToken"})," will be updated based on the time elapsed since the last lending event, ",(0,l.jsx)(n.code,{children:"rewardRate"})," will adjust according to the amount borrowed, and ",(0,l.jsx)(n.code,{children:"lastUpdated"})," will be updated to the timestamp of the most recent lending event. This process continues until the pool's active period concludes."]}),"\n",(0,l.jsx)(n.h3,{id:"pool-lifecycle",children:"Pool Lifecycle"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Event #1"}),": ",(0,l.jsx)(n.em,{children:"Contract is initialized with one pool using gold as collateral and USDC as the base token"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Event #2"}),": Alice supplies $100,000 to the pool."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Event #3"}),": Bob borrows $10,000 from the pool."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Event #4"}),": After 10 days, Bob repays the loan."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Event #5"}),": After 30 days, Alice withdraws her funds and claims her rewards."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This example illustrates how the contract behaves during these events."}),"\n",(0,l.jsx)(n.h3,{id:"event-1-contract-initialization",children:"Event #1: Contract Initialization"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The contract is initialized by setting the admin, the USDC token, and the pools."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"event-2-supplying-funds",children:"Event #2: Supplying Funds"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Only existing and active pools will allow the process to proceed."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Each pool has a minimum supply amount and a maximum USDC capacity, ensuring that the total supplied amount plus the repaid amount minus the borrowed amount does not exceed the capacity:"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-solidity",children:"lended + usdcAmount + repaid - borrowed <= maxPoolCapacity\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The contract requests USDC token approval to transfer the tokens from the user's wallet to the pool."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The reward update method is called."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"A lending record is created to store the supply information."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["An event ",(0,l.jsx)(n.code,{children:"newLend"})," is emitted."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Here's how the pool amounts look before and after the ",(0,l.jsx)(n.code,{children:"lend"})," function call:"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Before Lending:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "lended": 0,\n  "borrowed": 0,\n  "repaid": 0,\n  "rewards": 0,\n  "collateralTokenAmount": 0,\n  "rewardPerToken": 0,\n  "rewardRate": 0,\n  "lastUpdated": 0,\n  "interest": 10\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"After Lending:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "lended": 100000000000,\n  "borrowed": 0,\n  "repaid": 0,\n  "rewards": 0,\n  "collateralTokenAmount": 0,\n  "rewardPerToken": 0,\n  "rewardRate": 0,\n  "lastUpdated": 1702328455,\n  "interest": 10\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Key attributes to track include ",(0,l.jsx)(n.code,{children:"lended"}),", ",(0,l.jsx)(n.code,{children:"lastUpdated"}),", ",(0,l.jsx)(n.code,{children:"rewardPerToken"}),", and ",(0,l.jsx)(n.code,{children:"rewardRate"}),". Initially, these values are set to 0, indicating no updates have occurred."]}),"\n",(0,l.jsx)(n.h3,{id:"event-3-borrowing-funds",children:"Event #3: Borrowing Funds"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Only existing and active pools will allow the process to proceed."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Each pool has a minimum borrowing amount, and to borrow, the pool must have sufficient funds to cover the amount, which is equivalent to:"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"[\n(lended + repaid + rewards - withdrawn - borrowed - claimedRewards) < amount_to_borrow\n]"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["The contract calculates the minimum collateral required based on the pool's ",(0,l.jsx)(n.a,{href:"/docs/resources/glossary#loan-to-value-ltv-ratio-also-called-collateral-token-percentage",children:"loan-to-value (LTV) ratio"}),", using an oracle to obtain the collateral token price. It then verifies that the provided collateral exceeds this minimum."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"When collateral tokens are transferred to the contract, a borrowing record is created to store the borrowing information, and pool values are updated accordingly."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"A final USDC token safe transfer is made to the borrower, representing the borrowed amount."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The reward update method is called."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["An event ",(0,l.jsx)(n.code,{children:"newBorrow"})," is emitted."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Here's how the pool amounts look after the ",(0,l.jsx)(n.code,{children:"borrow"})," function call:"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"After Borrowing:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "lended": "100000000000",\n  "borrowed": "10000000000",\n  "repaid": "0",\n  "rewards": "0",\n  "collateralTokenAmount": "310005811536712244302",\n  "rewardPerToken": "0",\n  "rewardRate": "317097919",\n  "lastUpdated": 1702329114,\n  "interest": 10\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"event-4-repaying-the-loan",children:"Event #4: Repaying the Loan"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Only existing pools will allow the process to proceed. It doesn't matter if the pool endtime already passed."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"To repay a loan, the contract checks that the loan has not already been paid by the borrower or a liquidator. Once validated, the contract calculates the interest for the repayment."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Borrowers can repay a loan partially; for instance, Bob could repay $5,000 of the $10,000 loan and return later to pay the remainder."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The contract requests USDC token approval to transfer the tokens from the user's wallet to the pool. Once completed, the contract returns the collateral tokens to the borrower."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The reward update method is called."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["An event ",(0,l.jsx)(n.code,{children:"Repaid"})," is emitted."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Here's how the pool amounts look after repaying:"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"After Repaying:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "lended": "100000000000",\n  "borrowed": "10000000000",\n  "repaid": "10000000000",\n  "rewards": "27397355",\n  "collateralTokenAmount": "0",\n  "rewardPerToken": "273973553309757",\n  "rewardRate": "0",\n  "lastUpdated": 1703196299,\n  "interest": 10\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"The total repaid amount is updated after the borrower repays the loan, leaving the pool with the full supply amount available for borrowing or withdrawal."}),"\n",(0,l.jsx)(n.h3,{id:"event-5-claiming-rewards",children:"Event #5: Claiming Rewards"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Only existing pools will allow the process to proceed. It doesn't matter if the pool endtime already passed."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"To withdraw and claim rewards, the pool must have sufficient funds to return the amount plus the rewards."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The contract allows partial withdrawals, enabling suppliers to withdraw and claim rewards whenever they wish, provided validations are met."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Once validations are complete, the contract pays the rewards owed to the supplier, calculated using the following formula:"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-solidity",children:"supplied amount + ( ( ( reward per token - reward per token ignored ) * supplied amount ) / 1e18 )\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["An event ",(0,l.jsx)(n.code,{children:"RewardsClaimed"})," is emitted."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Here's how the pool looks after withdrawal:"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"After Withdrawal:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "lended": "100000000000",\n  "borrowed": "10000000000",\n  "repaid": "10000000000",\n  "rewards": "27397355",\n  "collateralTokenAmount": "0",\n  "rewardPerToken": "273973553309757",\n  "rewardRate": "0",\n  "lastUpdated": 1703199699,\n  "interest": 10\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"The state remains unchanged because only the supply information is updated. After claiming, the object looks like this:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "amount": "100000000000",\n  "rewardPerTokenIgnored": "0",\n  "usdcAmount": "100000000000"\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Since no other user supplied funds to the pool, the ",(0,l.jsx)(n.code,{children:"rewardPerTokenIgnored"})," for Alice is 0, allowing her to claim the full reward."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(6540);const l={},o=r.createContext(l);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);