"use strict";(self.webpackChunkdocus=self.webpackChunkdocus||[]).push([[581],{4349:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"engage/smart-contracts/vesting-contract/vesting-smart-contract","title":"Introduction","description":"ERC20LazyVesting.sol is a smart contract that enables scalable, secure, and flexible token vesting using off-chain Merkle proofs and on-chain validation. Beneficiaries claim tokens progressively based on vesting schedules validated through Merkle roots.","source":"@site/docs/engage/smart-contracts/vesting-contract/introduction.md","sourceDirName":"engage/smart-contracts/vesting-contract","slug":"/engage/smart-contracts/vesting-contract/vesting-smart-contract","permalink":"/docs/engage/smart-contracts/vesting-contract/vesting-smart-contract","draft":false,"unlisted":false,"editUrl":"https://github.com/defactor-com/documentation/tree/main/docs/engage/smart-contracts/vesting-contract/introduction.md","tags":[{"inline":true,"label":"Vesting","permalink":"/docs/tags/vesting"}],"version":"current","sidebarPosition":3,"frontMatter":{"id":"vesting-smart-contract","title":"Introduction","sidebar_position":3,"tags":["Vesting"]},"sidebar":"docSidebar","previous":{"title":"Contract Actions","permalink":"/docs/engage/smart-contracts/vesting-contract/vesting-contract-actions"},"next":{"title":"Engage Back End API","permalink":"/docs/category/engage-back-end-api"}}');var t=s(4848),r=s(8453);const c={id:"vesting-smart-contract",title:"Introduction",sidebar_position:3,tags:["Vesting"]},o=void 0,l={},a=[{value:"Contract Versions",id:"contract-versions",level:2},{value:"Vesting Smart Contract Documentation",id:"vesting-smart-contract-documentation",level:2},{value:"Overview",id:"overview",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Constants",id:"constants",level:3},{value:"Roles",id:"roles",level:3},{value:"Vesting",id:"vesting",level:3},{value:"Withdrawals",id:"withdrawals",level:3},{value:"Functions",id:"functions",level:3},{value:"Core Functions",id:"core-functions",level:4},{value:"Admin &amp; Operator",id:"admin--operator",level:4},{value:"Withdraw Functions",id:"withdraw-functions",level:4},{value:"Internal Logic",id:"internal-logic",level:3},{value:"Events",id:"events",level:3},{value:"Security Considerations",id:"security-considerations",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ERC20LazyVesting.sol"})," is a smart contract that enables scalable, secure, and flexible token vesting using off-chain Merkle proofs and on-chain validation. Beneficiaries claim tokens progressively based on vesting schedules validated through Merkle roots."]}),"\n",(0,t.jsx)(n.h2,{id:"contract-versions",children:"Contract Versions"}),"\n",(0,t.jsx)(n.p,{children:"This contract currently exists in a single production version, with potential improvements in UI integrations and audit tooling planned for the future."}),"\n",(0,t.jsx)(n.h2,{id:"vesting-smart-contract-documentation",children:"Vesting Smart Contract Documentation"}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Lazy Vesting contract allows for the release of vested tokens over time through on-chain validation of off-chain Merkle proofs. Vesting schedules include cliffs, durations, initial amounts, and are stored as Merkle tree leaves off-chain. This model is gas-efficient and scalable for high-volume distributions."}),"\n",(0,t.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IERC20"}),": Interface for ERC20 token transfers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SafeERC20"}),": Wrapper for secure token interactions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AccessControl"}),": Role-based permission system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ReentrancyGuard"}),": Prevents reentrancy attacks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Pausable"}),": Enables pausing the contract in emergencies."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"constants",children:"Constants"}),"\n",(0,t.jsx)(n.p,{children:"There are no named public constants, but key timing behaviors include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"30-day delay"}),": Required after ",(0,t.jsx)(n.code,{children:"requestWithdraw"})," before ",(0,t.jsx)(n.code,{children:"withdraw"})," is permitted."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merkle Proofs"}),": Used to validate schedules without storing them on-chain."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"roles",children:"Roles"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DEFAULT_ADMIN_ROLE"}),": Can pause/unpause the contract, request/execute withdrawals, and assign roles."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OPERATOR_ROLE"}),": Can register valid Merkle roots and revoke schedules."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"vesting",children:"Vesting"}),"\n",(0,t.jsx)(n.p,{children:"Each vesting schedule is uniquely identified and validated using Merkle proofs. The structure includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"cliff"}),": Time before vesting starts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"start"}),": Vesting schedule start time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"duration"}),": Total duration for full vesting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"secondsPerSlice"}),": Interval between vesting unlocks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"beneficiary"}),": Address eligible to claim tokens."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tokenAddress"}),": ERC20 token being vested."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"amount"}),": Total amount vesting over time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"initialAmount"}),": Tokens released at ",(0,t.jsx)(n.code,{children:"start"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Schedules are grouped into Merkle trees whose roots must be pre-approved by an operator."}),"\n",(0,t.jsx)(n.h3,{id:"withdrawals",children:"Withdrawals"}),"\n",(0,t.jsx)(n.p,{children:"Admins can request and execute token withdrawals from the contract under strict rules."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"requestWithdraw"}),": Starts a 30-day cooldown to allow transparency and dispute handling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"withdraw"}),": After 30 days, transfers any unallocated tokens to a specified recipient."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(n.h4,{id:"core-functions",children:"Core Functions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"release"}),": Transfers vested tokens to the beneficiary after validating the Merkle proof."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"getReleasedAmount"}),": Returns the total amount already claimed by the beneficiary."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"getReleasableAmount"}),": Returns the total claimable amount at the current time."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"admin--operator",children:"Admin & Operator"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"addValidMerkletreeRoot"}),": Marks a Merkle root as valid or invalid."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"revokeSchedules"}),": Revokes vesting schedules (Merkle leaves) to block further claims."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pause"}),": Emergency pause on ",(0,t.jsx)(n.code,{children:"release"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"unpause"}),": Resumes contract operations."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"withdraw-functions",children:"Withdraw Functions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"requestWithdraw"}),": Announces intent to withdraw tokens (starts 30-day timer)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"withdraw"}),": Executes token withdrawal after 30 days."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"internal-logic",children:"Internal Logic"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"_validateVestingSchedule"}),": Confirms Merkle proof validity and computes the root."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"_getReleasableAmount"}),": Determines tokens available based on current time and schedule state."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"_computeRoot"}),": Rebuilds Merkle root from a given leaf and proof using ",(0,t.jsx)(n.code,{children:"keccak256"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Released"}),": Emitted when tokens are released to a beneficiary."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MerkletreeRootAdded"}),": Emitted when a new Merkle root is marked valid."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SchedulesRevoked"}),": Emitted when vesting schedules are revoked."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AnnounceTokensWithdrawal"}),": Emitted upon withdrawal request."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"TokensWithdrawn"}),": Emitted when tokens are withdrawn by the admin."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merkle Proofs"}),": Off-chain generation and on-chain verification reduce storage cost while ensuring data integrity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Revocation Mechanism"}),": Allows operators to cancel schedules for security or business logic purposes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"30-Day Withdrawal Delay"}),": Ensures transparency and reduces risks of misuse by requiring early announcement."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Access Control"}),": Role-based architecture isolates permissions between admins and operators."]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Note: All schedules are validated via off-chain computed Merkle trees. This approach is optimized for mass distributions and minimizes on-chain complexity."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var i=s(6540);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);